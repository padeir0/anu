# Anu Bootstrap Compiler

Hacky compiler just to get it done, i'm tired of using other languages.

# Compiler Pipeline

```
     | file
     v                                      
 --------------  module   ----------------- 
 | resolution | --------> | cyclechecking | 
 --------------           ----------------- 
  | file     ^                    module |  
  v      ast |                           v  
 ------------------         ----------------
 | lexer | parser |         | typechecking |
 ------------------         ----------------
                             typed module | 
                                          V 
 -------------------  hir  -----------------
 | unique checking | <---- | linearization |
 -------------------       -----------------
  | hir + lifetime                          
  V                                         
 ------------         lir       ------------
 | lowering | ----------------> | resalloc |
 ------------                   ------------
                                     mdir | 
                                          V 
 --------          fasm code    ------------
 | fasm | <---------------------| fasm gen |
 --------                       ------------
  | elf                                     
  v                                         
```

```
Lexer
  Is called on-demand by the parser
  returns only one error
Parsing
  returns only one error
Resolution
  Recursively calls the Parser for each module
  Checks modules for circularity
  Creates Scopes and resolves names
  returns multiple errors (one per module)
Cyclechecking
  Checks types and constants for circularity
Typechecker
  Recursively calls itself for each module
  Infers and typechecks symbols in topological order
  Internalizes the types so identity can be checked by id/pointer comparison
Linearization: AST -> HIR Transformation
  Value flow
  Strings are internalized
  Constants are set in an Init procedure (that runs before main)
  Cast instructions for Unions
  High level operations (array append, New, slice, etc)
  Only simple numerical literals
  All complex literals are destructured (array and product literals)
    _new + insertion One by one
  CFG with only conditional and direct branching ('return' is a instruction)
  Product access is inlined in a single operand (easier to lower)
Unique Checking
  Uses HIR to validate uniqueness of references
  Analises lifetimes and annotates HIR
  Raises warnings for unused variables
Lowering
  Converts maps and related operations to simpler data types
  Converts arrays to Ptr -> [size, cap, items...]
  Inserts allocs and frees
  Only basic operations
    High level operations like copy, append, free, new* are destructured into simple procedure calls
    Type-related operations like comparison, hashing etc are destructured too
      (when SIMD is introduced, some of these operations might be linked later)
  Operations only on basic and Proc types
Resalloc: LIR -> MDIR Transformation (reuse Millipascal's backend)
  Address based access into objects
  Explicit stack frame management
    Slot based indexing into the stack frame
    Only i8, i16, i32, i64, ptr, bool and proc in the stack frame
    Callee Interprocedural, Caller Interprocedural, Spill and Local regions
  Explicit Register management
fasm generation: MDIR -> FASM
```

I have no fucking idea how 'mmap' works, so i will just use a 8~32Mb static memory region,
i'll care about this later, it will be a fun challenge to write the YMCA compiler with a
~32mb heap.

### HIR:

While in HIR, operands can have the following classes:

```
  temp  lit  local  global  internal  arg
```

A *temp* is a clean value that can only be instatiated and never mutated.

A *lit* is a numeric literal

A *global* is user defined constant, it may be set only in the `init` internal procedure

An *internal* is like a *global* but is generated by the compiler to deal with initializations,
string interning and so on.

A *local* is a variable declared inside a procedure, they are identified by name and scope depth.

An *arg* is an immutable argument passed to a procedure

Instructions:

```
  Add [number, number] -> number
  Sub
  Div
  Mult [number, number] -> ?number
  Rem

  Eq [comparable, comparable] -> comparable
  Diff
  Less [orderable, orderable] -> orderable
  More
  LessEq
  MoreEq

  Or [bool, bool] -> bool
  And

  Not [bool] -> bool
  Neg [number] -> number

  Convert [castable] -> castable

  Is [sum, type] -> bool

  _new [type] -> new_value
  MakeArray [size, type, initial_value] -> new_array
  MakeMap [capacity, type] -> new_map

  TakeRef [source] -> destination
  Copy [source] -> destination
  Swap [ref1, ref2]
  MapInsert [map, key, value]
  ArrayInsert [array, index, value]
  
  _aliasCast [sum_value] -> new_value
  Concat [array1, array2] -> array3
  Slice [array, begin, length] -> array2

  _addressElement [array, index] -> value
  Index  [array, number] -> item
  _firstPair [map] -> keyValuePair
  _nextPair [map, currentPair] -> keyValuePair
  MapLookUp [map, key] -> item
  MapRemove [map, key] -> item

  Stringify [value] -> str
  
  LoadRef:T of Any  [ref] -> value
  StoreRef:T of Any [value, ref]

  Call [proc, arg0, ..., argN] -> ret0, ..., retN
  _return ret0, ..., retN
```

Note:

 - product access is inlined as an operand 'a.b.c' instead of being
a instruction so lowering is easier.
 - instructions starting with underscore `_` are potentially unsafe
 - Bubble-up `^` is desugared into a proper branch with return, with
unsafe cast underneath.
 - `switch` is desugared into a chain of `if`s and unsafe casts
 - `for` and `for range` are desugared into proper branches
 - `for each` on arrays is desugared with unsafe interior pointers
 - `for each` on maps is desugared into linked list iteration
 - `-=`, `+=`, `*=` already exist in three address code
 - product, array and map literals are destructured in a unsafe allocation
plus setting each field in order
 - variables are addressed by their names and scope depth
