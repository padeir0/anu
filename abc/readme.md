# Anu Bootstrap Compiler

Hacky compiler just to get it done, i'm tired of using other languages.

# Compiler Pipeline

```
Lexer   - trivial
Parsing - trivial
Name Resolution
  Recursively calls the Parser for each module
  Creates Scopes and resolves names
Typechecker
  Checks modules for circularity
  Recursively calls itself for each module
  Infers and typechecks symbols in topological order
  Internalizes the types so identity can be checked by id/pointer comparison
AST -> HIR Transformation
  Value flow
  Full types
  Strings are internalized
  Constants are set in an Init procedure (that runs before main)
  Cast instructions for Unions
  High level operations (array append, New, slice, etc)
  Only simple numerical literals
  All complex literals are destructured (array and product literals)
    have a instruction that creates a tuple: make 1, 2, 3 -> t
  CFG with only conditional and direct branching ('return' is a instruction)
  Product access is inlined in a single operand (easier to lower)
Borrow Checking
  Uses HIR to validate affinity of references
  Analises lifetimes and inserts frees where it sees fit (may be another pass)
  Raises warnings for unused variables
HIR -> MIR Transformation
  Flat types
  Operations only on basic types
    High level operations like copy, append, free, new* are destructured into simple procedure calls
    Type-related operations like comparison, hashing etc are destructured too
  Index based access into objects
MIR -> LIR Transformation (reuse Millipascal's backend)
  Blobby objects
  Address based access into objects
  Explicit stack frame management
    Slot based indexing into the stack frame
    Only i8, i16, i32, i64, ptr, bool and proc in the stack frame
    Callee Interprocedural, Caller Interprocedural, Spill and Local regions
  Explicit Register management
LIR -> FASM
```

I have no fucking idea how 'mmap' works, so i will just use a 8~32Mb static memory region,
i'll care about this later, it will be a fun challenge to write the YMCA compiler with a
32mb heap.

### HIR:

While in HIR, operands can have the following classes:

```
  temp  lit  local  global  internal  arg
```

A *temp* is a clean value that can only be instatiated and never mutated.

A *lit* is a numeric literal

A *global* is user defined constant, it may be set only in the `init` internal procedure

An *internal* is like a *global* but is generated by the compiler to deal with initializations,
string interning and so on.

A *local* is a variable declared inside a procedure, they are identified by name and scope depth.

An *arg* is an immutable argument passed to a procedure

Instructions:

```
  Add [number, number] -> number
  Sub
  Div
  Mult [number, number] -> ?number
  Rem

  Eq [comparable, comparable] -> comparable
  Diff
  Less [orderable, orderable] -> orderable
  More
  LessEq
  MoreEq

  Or [bool, bool] -> bool
  And

  Not [bool] -> bool
  Neg [number] -> number

  Convert [castable] -> castable

  Is [sum, type] -> bool

  _new [type] -> new_value
  MakeArray [size, type, initial_value] -> new_array
  MakeMap [capacity, type] -> new_map

  TakeRef [source] -> destination
  Copy [source] -> destination
  Swap [ref1, ref2]
  MapInsert [map, key, value]
  ArrayInsert [array, index, value]
  
  _aliasCast [sum_value] -> new_value
  Concat [array1, array2] -> array3
  Slice [array, begin, length] -> array2

  _addressElement [array, index] -> value
  Index  [array, number] -> item
  MapLookUp [map, key] -> item
  MapRemove [map, key] -> item

  Stringify [value] -> str
  
  LoadRef:T of Any  [ref] -> value
  StoreRef:T of Any [value, ref]

  Call [proc, arg0, ..., argN] -> ret0, ..., retN
  _return ret0, ..., retN
```

Note:

 - product access is inlined as an operand 'a.b.c' instead of being
a instruction so lowering is easier.
 - instructions starting with underscore `_` are potentially unsafe
 - Bubble-up `^` is desugared into a proper branch with return, with
unsafe cast underneath.
 - `switch` is desugared into a chain of `if`s and unsafe casts
 - `for` and `for range` are desugared into proper branches 
 - `for each` is desugared with unsafe interior pointers
 - `-=`, `+=`, `*=` already exist in three address code
 - product, array and map literals are destructured in a unsafe allocation
plus setting each field in order
 - variables are addressed by their names and scope depth
